برای اینکه مشکل "لودینگ تمام صفحه" (Blocking Overlay) را حل کنیم و تجربه کاربری بهتری داشته باشیم، باید رفتار تابع `refreshData` را تغییر دهیم.

در حال حاضر، هر بار که این تابع صدا زده می‌شود (چه دستی و چه خودکار)، تابع `showLoading()` اجرا می‌شود که کل صفحه را قفل می‌کند.

### راهکار: لودینگ "خاموش" (Silent) برای رفرش خودکار و لودینگ "دکمه‌ای" برای رفرش دستی

تغییرات زیر را در فایل `templates/dashboard.html` اعمال کنید.

#### ۱. اصلاح تابع `refreshData`

این تابع را در بخش `<script>` پیدا کنید و با کد زیر جایگزین کنید. این کد جدید یک پارامتر `isSilent` می‌گیرد.

  * اگر **رفرش خودکار** باشد (`isSilent=true`): هیچ لودینگی نشان نمی‌دهد (فقط اعداد آپدیت می‌شوند).
  * اگر **رفرش دستی** باشد: به جای قفل کردن کل صفحه، فقط دکمه "Refresh" حالت چرخشی (Spinner) می‌گیرد.

<!-- end list -->

```javascript
    // تابع اصلاح شده refreshData
    async function refreshData(isSilent = false) {
        const refreshBtn = document.querySelector('.header-controls .btn-primary'); // پیدا کردن دکمه رفرش
        
        // اگر رفرش دستی بود (سایلنت نبود)
        if (!isSilent) {
            if (refreshBtn) {
                // ذخیره متن اصلی دکمه برای برگرداندن بعد از اتمام
                if (!refreshBtn.dataset.originalContent) {
                    refreshBtn.dataset.originalContent = refreshBtn.innerHTML;
                }
                
                // غیرفعال کردن دکمه و نمایش اسپینر کوچک داخل دکمه
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '<div class="spinner" style="width: 16px; height: 16px; border-width: 2px; border-color: rgba(255,255,255,0.2); border-top-color: white;"></div> Refreshing';
            } else {
                // اگر دکمه پیدا نشد، همان لودینگ اصلی را نشان بده (حالت فال‌بک)
                showLoading();
            }
        }
        
        try {
            const response = await fetch('/api/refresh');
            const data = await response.json();
            
            if (data.success) {
                updateStats(data.stats, data.server_count);
                updateInbounds(data.inbounds);
                inboundsData = data.inbounds;
                
                const failedServers = data.servers?.filter(s => !s.success) || [];
                if (failedServers.length > 0) {
                    const errors = failedServers.map(s => `${s.server_name}: ${s.error}`).join(', ');
                    showToast('Server errors: ' + errors, 'error');
                }
                // اگر رفرش دستی بود، پیام موفقیت بده
                if (!isSilent) showToast('Data updated successfully');
            } else {
                if (!isSilent) showToast('Error loading data', 'error');
            }
        } catch (error) {
            console.error('Refresh error:', error);
            if (!isSilent) showToast('Error updating: ' + error.message, 'error');
        } finally {
            // پایان عملیات
            if (!isSilent) {
                if (refreshBtn) {
                    // برگرداندن دکمه به حالت اول
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = refreshBtn.dataset.originalContent;
                } else {
                    hideLoading();
                }
            }
            // اطمینان از بسته شدن لودینگ اصلی در هر حالت
            hideLoading();
        }
    }
```

#### ۲. اصلاح تابع `startAutoRefresh`

حالا باید به سیستم بگوییم وقتی تایمر (مثلا هر ۶۰ ثانیه) عمل می‌کند، رفرش را به صورت `silent` انجام دهد.

تابع `startAutoRefresh` را پیدا کنید و خط `setInterval` را تغییر دهید:

```javascript
    function startAutoRefresh() {
        stopAutoRefresh();
        const interval = parseInt(document.getElementById('refresh-interval').value) * 1000;
        
        // تغییر مهم: ارسال true به عنوان پارامتر برای حالت بدون لودینگ
        autoRefreshInterval = setInterval(() => refreshData(true), interval);
    }
```

#### ۳. اصلاح `DOMContentLoaded` (لود اولیه)

برای بار اول که صفحه باز می‌شود، معمولاً دوست داریم لودینگ کامل نمایش داده شود تا کاربر بفهمد صفحه در حال آماده‌سازی است. پس کد آن را تغییر نمی‌دهیم یا به صورت صریح `false` می‌فرستیم:

```javascript
    document.addEventListener('DOMContentLoaded', function() {
        showLoading(); // نمایش لودینگ فقط برای بار اول
        refreshData(true).then(() => hideLoading()); // دیتا را بگیر و بعد لودینگ را ببند
        loadServers();
    });
```

### نتیجه:

1.  **رفرش خودکار:** کاربر هیچ وقفه‌ای حس نمی‌کند، فقط اعداد و نمودارها ناگهان آپدیت می‌شوند.
2.  **دکمه Refresh:** وقتی کاربر روی آن کلیک می‌کند، کل صفحه سیاه نمی‌شود؛ فقط خود دکمه به حالت "Refreshing..." می‌رود و می‌چرخد تا کار تمام شود.